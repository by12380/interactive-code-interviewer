// Expanded question bank – 80+ LeetCode-style problems across all major categories.
// Each problem follows the same shape as the original PROBLEMS array so existing
// components can render them without changes.
//
// Categories: Arrays & Hashing, Two Pointers, Sliding Window, Stack, Binary Search,
//             Linked Lists, Trees, Graphs, Dynamic Programming, Backtracking

export const QUESTION_BANK = [
  // ═══════════════════════  ARRAYS & HASHING  ═══════════════════════
  {
    id: "two-sum",
    title: "Two Sum",
    difficulty: "Easy",
    category: "Arrays & Hashing",
    description: "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.",
    starterCode: "function twoSum(nums, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [2,7,11,15], target: 9 }, expected: [0,1] },
      { input: { nums: [3,2,4], target: 6 }, expected: [1,2] },
      { input: { nums: [3,3], target: 6 }, expected: [0,1] },
    ],
    hints: ["Use a hash map for O(1) lookups.", "For each element, check if target - element exists in the map."],
    solution: "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const need = target - nums[i];\n    if (map.has(need)) return [map.get(need), i];\n    map.set(nums[i], i);\n  }\n  return [];\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "contains-duplicate",
    title: "Contains Duplicate",
    difficulty: "Easy",
    category: "Arrays & Hashing",
    description: "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
    starterCode: "function containsDuplicate(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,2,3,1] }, expected: true },
      { input: { nums: [1,2,3,4] }, expected: false },
      { input: { nums: [1,1,1,3,3,4,3,2,4,2] }, expected: true },
    ],
    hints: ["A Set automatically handles uniqueness."],
    solution: "function containsDuplicate(nums) {\n  return new Set(nums).size !== nums.length;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "valid-anagram",
    title: "Valid Anagram",
    difficulty: "Easy",
    category: "Arrays & Hashing",
    description: "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.",
    starterCode: "function isAnagram(s, t) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "anagram", t: "nagaram" }, expected: true },
      { input: { s: "rat", t: "car" }, expected: false },
    ],
    hints: ["Count character frequencies with a map."],
    solution: "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const count = {};\n  for (const c of s) count[c] = (count[c] || 0) + 1;\n  for (const c of t) { count[c] = (count[c] || 0) - 1; if (count[c] < 0) return false; }\n  return true;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "group-anagrams",
    title: "Group Anagrams",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
    starterCode: "function groupAnagrams(strs) {\n  // Your solution here\n}",
    testCases: [
      { input: { strs: ["eat","tea","tan","ate","nat","bat"] }, expected: [["eat","tea","ate"],["tan","nat"],["bat"]] },
      { input: { strs: [""] }, expected: [[""]] },
    ],
    hints: ["Sort each word and use the sorted version as a map key."],
    solution: "function groupAnagrams(strs) {\n  const map = new Map();\n  for (const s of strs) {\n    const key = [...s].sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(s);\n  }\n  return [...map.values()];\n}",
    optimalComplexity: "O(n * k log k)",
  },
  {
    id: "top-k-frequent",
    title: "Top K Frequent Elements",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements.",
    starterCode: "function topKFrequent(nums, k) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,1,1,2,2,3], k: 2 }, expected: [1,2] },
      { input: { nums: [1], k: 1 }, expected: [1] },
    ],
    hints: ["Use a frequency map then bucket sort."],
    solution: "function topKFrequent(nums, k) {\n  const freq = new Map();\n  for (const n of nums) freq.set(n, (freq.get(n)||0)+1);\n  return [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0,k).map(e=>e[0]);\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "product-except-self",
    title: "Product of Array Except Self",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. You must write an algorithm that runs in O(n) time without using division.",
    starterCode: "function productExceptSelf(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,2,3,4] }, expected: [24,12,8,6] },
      { input: { nums: [-1,1,0,-3,3] }, expected: [0,0,9,0,0] },
    ],
    hints: ["Use prefix and suffix products."],
    solution: "function productExceptSelf(nums) {\n  const n = nums.length, res = Array(n).fill(1);\n  let pre = 1;\n  for (let i = 0; i < n; i++) { res[i] = pre; pre *= nums[i]; }\n  let suf = 1;\n  for (let i = n-1; i >= 0; i--) { res[i] *= suf; suf *= nums[i]; }\n  return res;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "longest-consecutive",
    title: "Longest Consecutive Sequence",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
    starterCode: "function longestConsecutive(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [100,4,200,1,3,2] }, expected: 4 },
      { input: { nums: [0,3,7,2,5,8,4,6,0,1] }, expected: 9 },
    ],
    hints: ["Use a Set. Only start counting from sequence beginnings (no num-1 in set)."],
    solution: "function longestConsecutive(nums) {\n  const s = new Set(nums);\n  let best = 0;\n  for (const n of s) {\n    if (!s.has(n-1)) {\n      let len = 1;\n      while (s.has(n+len)) len++;\n      best = Math.max(best, len);\n    }\n  }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "encode-decode-strings",
    title: "Encode and Decode Strings",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Design an algorithm to encode a list of strings to a single string, and decode it back.",
    starterCode: "function encode(strs) {\n  // Your solution here\n}\n\nfunction decode(s) {\n  // Your solution here\n}",
    testCases: [
      { input: { strs: ["hello","world"] }, expected: ["hello","world"] },
      { input: { strs: [""] }, expected: [""] },
    ],
    hints: ["Prefix each string with its length and a delimiter."],
    solution: "function encode(strs) {\n  return strs.map(s => s.length + '#' + s).join('');\n}\nfunction decode(s) {\n  const res = []; let i = 0;\n  while (i < s.length) {\n    let j = i;\n    while (s[j] !== '#') j++;\n    const len = Number(s.slice(i, j));\n    res.push(s.slice(j+1, j+1+len));\n    i = j+1+len;\n  }\n  return res;\n}",
    optimalComplexity: "O(n)",
  },
  // More arrays & hashing
  {
    id: "majority-element",
    title: "Majority Element",
    difficulty: "Easy",
    category: "Arrays & Hashing",
    description: "Given an array `nums` of size `n`, return the majority element. The majority element is the element that appears more than `⌊n / 2⌋` times.",
    starterCode: "function majorityElement(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [3,2,3] }, expected: 3 },
      { input: { nums: [2,2,1,1,1,2,2] }, expected: 2 },
    ],
    hints: ["Boyer-Moore voting algorithm."],
    solution: "function majorityElement(nums) {\n  let count = 0, candidate;\n  for (const n of nums) {\n    if (count === 0) candidate = n;\n    count += n === candidate ? 1 : -1;\n  }\n  return candidate;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "valid-sudoku",
    title: "Valid Sudoku",
    difficulty: "Medium",
    category: "Arrays & Hashing",
    description: "Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated.",
    starterCode: "function isValidSudoku(board) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Use sets for each row, column, and 3x3 box."],
    solution: "function isValidSudoku(board) {\n  const rows = Array.from({length:9},()=>new Set());\n  const cols = Array.from({length:9},()=>new Set());\n  const boxes = Array.from({length:9},()=>new Set());\n  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {\n    const v = board[r][c];\n    if (v==='.') continue;\n    const b = Math.floor(r/3)*3+Math.floor(c/3);\n    if (rows[r].has(v)||cols[c].has(v)||boxes[b].has(v)) return false;\n    rows[r].add(v); cols[c].add(v); boxes[b].add(v);\n  }\n  return true;\n}",
    optimalComplexity: "O(1)",
  },

  // ═══════════════════════  TWO POINTERS  ═══════════════════════════
  {
    id: "valid-palindrome",
    title: "Valid Palindrome",
    difficulty: "Easy",
    category: "Two Pointers",
    description: "Given a string `s`, return `true` if it is a palindrome considering only alphanumeric characters and ignoring cases.",
    starterCode: "function isPalindrome(s) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "A man, a plan, a canal: Panama" }, expected: true },
      { input: { s: "race a car" }, expected: false },
    ],
    hints: ["Use two pointers from both ends, skip non-alphanumeric."],
    solution: "function isPalindrome(s) {\n  const clean = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let l=0, r=clean.length-1;\n  while (l<r) { if (clean[l]!==clean[r]) return false; l++; r--; }\n  return true;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "two-sum-ii",
    title: "Two Sum II - Input Array Is Sorted",
    difficulty: "Medium",
    category: "Two Pointers",
    description: "Given a 1-indexed sorted array `numbers`, find two numbers that add up to `target`. Return their indices.",
    starterCode: "function twoSumII(numbers, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { numbers: [2,7,11,15], target: 9 }, expected: [1,2] },
      { input: { numbers: [2,3,4], target: 6 }, expected: [1,3] },
    ],
    hints: ["Two pointers: one at start, one at end."],
    solution: "function twoSumII(numbers, target) {\n  let l=0, r=numbers.length-1;\n  while (l<r) {\n    const s = numbers[l]+numbers[r];\n    if (s===target) return [l+1,r+1];\n    if (s<target) l++; else r--;\n  }\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "three-sum",
    title: "3Sum",
    difficulty: "Medium",
    category: "Two Pointers",
    description: "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.",
    starterCode: "function threeSum(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [-1,0,1,2,-1,-4] }, expected: [[-1,-1,2],[-1,0,1]] },
    ],
    hints: ["Sort, fix one element, two-pointer on the rest."],
    solution: "function threeSum(nums) {\n  nums.sort((a,b)=>a-b);\n  const res=[];\n  for (let i=0;i<nums.length-2;i++) {\n    if (i>0&&nums[i]===nums[i-1]) continue;\n    let l=i+1,r=nums.length-1;\n    while(l<r) {\n      const s=nums[i]+nums[l]+nums[r];\n      if (s===0) { res.push([nums[i],nums[l],nums[r]]); while(l<r&&nums[l]===nums[l+1])l++; while(l<r&&nums[r]===nums[r-1])r--; l++;r--; }\n      else if (s<0) l++; else r--;\n    }\n  }\n  return res;\n}",
    optimalComplexity: "O(n^2)",
  },
  {
    id: "container-with-most-water",
    title: "Container With Most Water",
    difficulty: "Medium",
    category: "Two Pointers",
    description: "Given `n` non-negative integers `height`, find two lines that together with the x-axis form a container that holds the most water.",
    starterCode: "function maxArea(height) {\n  // Your solution here\n}",
    testCases: [
      { input: { height: [1,8,6,2,5,4,8,3,7] }, expected: 49 },
    ],
    hints: ["Two pointers from both ends; move the shorter line inward."],
    solution: "function maxArea(height) {\n  let l=0,r=height.length-1,best=0;\n  while(l<r) {\n    best=Math.max(best,Math.min(height[l],height[r])*(r-l));\n    if (height[l]<height[r]) l++; else r--;\n  }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "trapping-rain-water",
    title: "Trapping Rain Water",
    difficulty: "Hard",
    category: "Two Pointers",
    description: "Given `n` non-negative integers representing an elevation map, compute how much water it can trap after raining.",
    starterCode: "function trap(height) {\n  // Your solution here\n}",
    testCases: [
      { input: { height: [0,1,0,2,1,0,1,3,2,1,2,1] }, expected: 6 },
    ],
    hints: ["Two pointers tracking max from both sides."],
    solution: "function trap(height) {\n  let l=0,r=height.length-1,lMax=0,rMax=0,water=0;\n  while(l<r) {\n    if (height[l]<height[r]) { lMax=Math.max(lMax,height[l]); water+=lMax-height[l]; l++; }\n    else { rMax=Math.max(rMax,height[r]); water+=rMax-height[r]; r--; }\n  }\n  return water;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "move-zeroes",
    title: "Move Zeroes",
    difficulty: "Easy",
    category: "Two Pointers",
    description: "Given an integer array `nums`, move all 0's to the end while maintaining the relative order of non-zero elements. Do it in-place.",
    starterCode: "function moveZeroes(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [0,1,0,3,12] }, expected: [1,3,12,0,0] },
    ],
    hints: ["Use a write pointer to place non-zero elements."],
    solution: "function moveZeroes(nums) {\n  let w=0;\n  for (let r=0;r<nums.length;r++) if (nums[r]!==0) { [nums[w],nums[r]]=[nums[r],nums[w]]; w++; }\n  return nums;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "remove-duplicates-sorted",
    title: "Remove Duplicates from Sorted Array",
    difficulty: "Easy",
    category: "Two Pointers",
    description: "Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once. Return the new length.",
    starterCode: "function removeDuplicates(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,1,2] }, expected: 2 },
      { input: { nums: [0,0,1,1,1,2,2,3,3,4] }, expected: 5 },
    ],
    hints: ["Slow/fast pointer."],
    solution: "function removeDuplicates(nums) {\n  if (!nums.length) return 0;\n  let w=0;\n  for (let r=1;r<nums.length;r++) if (nums[r]!==nums[w]) { w++; nums[w]=nums[r]; }\n  return w+1;\n}",
    optimalComplexity: "O(n)",
  },

  // ═══════════════════════  SLIDING WINDOW  ═════════════════════════
  {
    id: "best-time-buy-sell",
    title: "Best Time to Buy and Sell Stock",
    difficulty: "Easy",
    category: "Sliding Window",
    description: "Given an array `prices`, return the maximum profit from buying on one day and selling on a later day.",
    starterCode: "function maxProfit(prices) {\n  // Your solution here\n}",
    testCases: [
      { input: { prices: [7,1,5,3,6,4] }, expected: 5 },
      { input: { prices: [7,6,4,3,1] }, expected: 0 },
    ],
    hints: ["Track the minimum price seen so far."],
    solution: "function maxProfit(prices) {\n  let min=Infinity, best=0;\n  for (const p of prices) { min=Math.min(min,p); best=Math.max(best,p-min); }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "longest-substring-no-repeat",
    title: "Longest Substring Without Repeating Characters",
    difficulty: "Medium",
    category: "Sliding Window",
    description: "Given a string `s`, find the length of the longest substring without repeating characters.",
    starterCode: "function lengthOfLongestSubstring(s) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "abcabcbb" }, expected: 3 },
      { input: { s: "bbbbb" }, expected: 1 },
      { input: { s: "pwwkew" }, expected: 3 },
    ],
    hints: ["Sliding window with a Set or Map."],
    solution: "function lengthOfLongestSubstring(s) {\n  const seen=new Map(); let l=0,best=0;\n  for (let r=0;r<s.length;r++) {\n    if (seen.has(s[r])) l=Math.max(l,seen.get(s[r])+1);\n    seen.set(s[r],r); best=Math.max(best,r-l+1);\n  }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "longest-repeating-char-replacement",
    title: "Longest Repeating Character Replacement",
    difficulty: "Medium",
    category: "Sliding Window",
    description: "Given string `s` and integer `k`, find the length of the longest substring containing the same letter after performing at most `k` changes.",
    starterCode: "function characterReplacement(s, k) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "ABAB", k: 2 }, expected: 4 },
      { input: { s: "AABABBA", k: 1 }, expected: 4 },
    ],
    hints: ["Sliding window; track most frequent char count."],
    solution: "function characterReplacement(s, k) {\n  const count={}; let l=0,maxF=0,best=0;\n  for (let r=0;r<s.length;r++) {\n    count[s[r]]=(count[s[r]]||0)+1;\n    maxF=Math.max(maxF,count[s[r]]);\n    while(r-l+1-maxF>k) { count[s[l]]--; l++; }\n    best=Math.max(best,r-l+1);\n  }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "minimum-window-substring",
    title: "Minimum Window Substring",
    difficulty: "Hard",
    category: "Sliding Window",
    description: "Given two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` is included in the window.",
    starterCode: "function minWindow(s, t) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "ADOBECODEBANC", t: "ABC" }, expected: "BANC" },
    ],
    hints: ["Sliding window with frequency map + have/need counters."],
    solution: "function minWindow(s, t) {\n  const need=new Map();\n  for (const c of t) need.set(c,(need.get(c)||0)+1);\n  let have=0,needCount=need.size,l=0,best=[0,Infinity];\n  const win=new Map();\n  for (let r=0;r<s.length;r++) {\n    win.set(s[r],(win.get(s[r])||0)+1);\n    if (need.has(s[r])&&win.get(s[r])===need.get(s[r])) have++;\n    while(have===needCount) {\n      if (r-l<best[1]-best[0]) best=[l,r];\n      win.set(s[l],win.get(s[l])-1);\n      if (need.has(s[l])&&win.get(s[l])<need.get(s[l])) have--;\n      l++;\n    }\n  }\n  return best[1]===Infinity?'':s.slice(best[0],best[1]+1);\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "permutation-in-string",
    title: "Permutation in String",
    difficulty: "Medium",
    category: "Sliding Window",
    description: "Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`.",
    starterCode: "function checkInclusion(s1, s2) {\n  // Your solution here\n}",
    testCases: [
      { input: { s1: "ab", s2: "eidbaooo" }, expected: true },
      { input: { s1: "ab", s2: "eidboaoo" }, expected: false },
    ],
    hints: ["Fixed-size sliding window of length s1."],
    solution: "function checkInclusion(s1,s2) {\n  if (s1.length>s2.length) return false;\n  const c1=Array(26).fill(0),c2=Array(26).fill(0);\n  const idx=c=>c.charCodeAt(0)-97;\n  for (let i=0;i<s1.length;i++) { c1[idx(s1[i])]++; c2[idx(s2[i])]++; }\n  const eq=()=>c1.every((v,i)=>v===c2[i]);\n  if (eq()) return true;\n  for (let i=s1.length;i<s2.length;i++) {\n    c2[idx(s2[i])]++; c2[idx(s2[i-s1.length])]--;\n    if (eq()) return true;\n  }\n  return false;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "max-sum-subarray-k",
    title: "Maximum Sum Subarray of Size K",
    difficulty: "Easy",
    category: "Sliding Window",
    description: "Given an array of integers and a number `k`, find the maximum sum of a subarray of size `k`.",
    starterCode: "function maxSumSubarray(nums, k) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [2,1,5,1,3,2], k: 3 }, expected: 9 },
      { input: { nums: [2,3,4,1,5], k: 2 }, expected: 7 },
    ],
    hints: ["Maintain a running sum; slide by adding right and removing left."],
    solution: "function maxSumSubarray(nums, k) {\n  let sum=0;\n  for (let i=0;i<k;i++) sum+=nums[i];\n  let best=sum;\n  for (let i=k;i<nums.length;i++) { sum+=nums[i]-nums[i-k]; best=Math.max(best,sum); }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },

  // ═══════════════════════  STACK  ══════════════════════════════════
  {
    id: "valid-parentheses",
    title: "Valid Parentheses",
    difficulty: "Easy",
    category: "Stack",
    description: "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    starterCode: "function isValid(s) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "()" }, expected: true },
      { input: { s: "()[]{}" }, expected: true },
      { input: { s: "(]" }, expected: false },
    ],
    hints: ["Push opening brackets, pop on closing."],
    solution: "function isValid(s) {\n  const stack=[], map={')':'(','}':'{',']':'['};\n  for (const c of s) {\n    if ('({['.includes(c)) stack.push(c);\n    else if (stack.pop()!==map[c]) return false;\n  }\n  return stack.length===0;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "min-stack",
    title: "Min Stack",
    difficulty: "Medium",
    category: "Stack",
    description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    starterCode: "class MinStack {\n  constructor() {\n    // Your solution here\n  }\n  push(val) {}\n  pop() {}\n  top() {}\n  getMin() {}\n}",
    testCases: [],
    hints: ["Use a second stack to track minimums."],
    solution: "class MinStack {\n  constructor() { this.stack=[]; this.minStack=[]; }\n  push(val) { this.stack.push(val); this.minStack.push(Math.min(val, this.minStack.length ? this.minStack[this.minStack.length-1] : val)); }\n  pop() { this.stack.pop(); this.minStack.pop(); }\n  top() { return this.stack[this.stack.length-1]; }\n  getMin() { return this.minStack[this.minStack.length-1]; }\n}",
    optimalComplexity: "O(1)",
  },
  {
    id: "evaluate-rpn",
    title: "Evaluate Reverse Polish Notation",
    difficulty: "Medium",
    category: "Stack",
    description: "Evaluate an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /.",
    starterCode: "function evalRPN(tokens) {\n  // Your solution here\n}",
    testCases: [
      { input: { tokens: ["2","1","+","3","*"] }, expected: 9 },
      { input: { tokens: ["4","13","5","/","+"] }, expected: 6 },
    ],
    hints: ["Stack: push numbers, pop two on operator."],
    solution: "function evalRPN(tokens) {\n  const stack=[];\n  for (const t of tokens) {\n    if ('+-*/'.includes(t)&&t.length===1) {\n      const b=stack.pop(), a=stack.pop();\n      if (t==='+') stack.push(a+b);\n      else if (t==='-') stack.push(a-b);\n      else if (t==='*') stack.push(a*b);\n      else stack.push(Math.trunc(a/b));\n    } else stack.push(Number(t));\n  }\n  return stack[0];\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "daily-temperatures",
    title: "Daily Temperatures",
    difficulty: "Medium",
    category: "Stack",
    description: "Given an array of integers `temperatures`, return an array where `answer[i]` is the number of days you have to wait until a warmer temperature.",
    starterCode: "function dailyTemperatures(temperatures) {\n  // Your solution here\n}",
    testCases: [
      { input: { temperatures: [73,74,75,71,69,72,76,73] }, expected: [1,1,4,2,1,1,0,0] },
    ],
    hints: ["Monotonic decreasing stack of indices."],
    solution: "function dailyTemperatures(temps) {\n  const res=Array(temps.length).fill(0), stack=[];\n  for (let i=0;i<temps.length;i++) {\n    while(stack.length&&temps[i]>temps[stack[stack.length-1]]) {\n      const j=stack.pop(); res[j]=i-j;\n    }\n    stack.push(i);\n  }\n  return res;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "largest-rectangle-histogram",
    title: "Largest Rectangle in Histogram",
    difficulty: "Hard",
    category: "Stack",
    description: "Given an array of integers `heights` representing the histogram's bar heights, find the area of the largest rectangle in the histogram.",
    starterCode: "function largestRectangleArea(heights) {\n  // Your solution here\n}",
    testCases: [
      { input: { heights: [2,1,5,6,2,3] }, expected: 10 },
    ],
    hints: ["Monotonic stack to find left/right boundaries."],
    solution: "function largestRectangleArea(heights) {\n  const stack=[], n=heights.length;\n  let best=0;\n  for (let i=0;i<=n;i++) {\n    const h=i===n?0:heights[i];\n    while(stack.length&&h<heights[stack[stack.length-1]]) {\n      const height=heights[stack.pop()];\n      const w=stack.length?i-stack[stack.length-1]-1:i;\n      best=Math.max(best,height*w);\n    }\n    stack.push(i);\n  }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "next-greater-element",
    title: "Next Greater Element I",
    difficulty: "Easy",
    category: "Stack",
    description: "Find the next greater element for each element in `nums1` using `nums2`.",
    starterCode: "function nextGreaterElement(nums1, nums2) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums1: [4,1,2], nums2: [1,3,4,2] }, expected: [-1,3,-1] },
    ],
    hints: ["Monotonic stack on nums2, store results in a map."],
    solution: "function nextGreaterElement(nums1, nums2) {\n  const map=new Map(), stack=[];\n  for (const n of nums2) {\n    while(stack.length&&stack[stack.length-1]<n) map.set(stack.pop(),n);\n    stack.push(n);\n  }\n  return nums1.map(n=>map.get(n)?? -1);\n}",
    optimalComplexity: "O(n)",
  },

  // ═══════════════════════  BINARY SEARCH  ══════════════════════════
  {
    id: "binary-search",
    title: "Binary Search",
    difficulty: "Easy",
    category: "Binary Search",
    description: "Given a sorted array `nums` and a `target`, return the index of `target` or `-1`.",
    starterCode: "function search(nums, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [-1,0,3,5,9,12], target: 9 }, expected: 4 },
      { input: { nums: [-1,0,3,5,9,12], target: 2 }, expected: -1 },
    ],
    hints: ["Classic binary search with left and right pointers."],
    solution: "function search(nums, target) {\n  let l=0,r=nums.length-1;\n  while(l<=r) {\n    const m=Math.floor((l+r)/2);\n    if (nums[m]===target) return m;\n    if (nums[m]<target) l=m+1; else r=m-1;\n  }\n  return -1;\n}",
    optimalComplexity: "O(log n)",
  },
  {
    id: "search-2d-matrix",
    title: "Search a 2D Matrix",
    difficulty: "Medium",
    category: "Binary Search",
    description: "Write an efficient algorithm that searches for a value `target` in a sorted m x n integer matrix.",
    starterCode: "function searchMatrix(matrix, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { matrix: [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target: 3 }, expected: true },
    ],
    hints: ["Treat the 2D matrix as a 1D sorted array."],
    solution: "function searchMatrix(matrix, target) {\n  const m=matrix.length,n=matrix[0].length;\n  let l=0,r=m*n-1;\n  while(l<=r) {\n    const mid=Math.floor((l+r)/2);\n    const val=matrix[Math.floor(mid/n)][mid%n];\n    if (val===target) return true;\n    if (val<target) l=mid+1; else r=mid-1;\n  }\n  return false;\n}",
    optimalComplexity: "O(log(m*n))",
  },
  {
    id: "koko-eating-bananas",
    title: "Koko Eating Bananas",
    difficulty: "Medium",
    category: "Binary Search",
    description: "Koko can eat at speed `k` bananas/hour. Return the minimum `k` to eat all bananas within `h` hours.",
    starterCode: "function minEatingSpeed(piles, h) {\n  // Your solution here\n}",
    testCases: [
      { input: { piles: [3,6,7,11], h: 8 }, expected: 4 },
    ],
    hints: ["Binary search on the answer: try different speeds."],
    solution: "function minEatingSpeed(piles, h) {\n  let l=1, r=Math.max(...piles);\n  while(l<r) {\n    const m=Math.floor((l+r)/2);\n    const hrs=piles.reduce((a,p)=>a+Math.ceil(p/m),0);\n    if (hrs<=h) r=m; else l=m+1;\n  }\n  return l;\n}",
    optimalComplexity: "O(n log m)",
  },
  {
    id: "find-minimum-rotated",
    title: "Find Minimum in Rotated Sorted Array",
    difficulty: "Medium",
    category: "Binary Search",
    description: "Given a rotated sorted array `nums`, find the minimum element.",
    starterCode: "function findMin(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [3,4,5,1,2] }, expected: 1 },
      { input: { nums: [4,5,6,7,0,1,2] }, expected: 0 },
    ],
    hints: ["Binary search: compare mid with right boundary."],
    solution: "function findMin(nums) {\n  let l=0,r=nums.length-1;\n  while(l<r) {\n    const m=Math.floor((l+r)/2);\n    if (nums[m]>nums[r]) l=m+1; else r=m;\n  }\n  return nums[l];\n}",
    optimalComplexity: "O(log n)",
  },
  {
    id: "search-rotated-sorted",
    title: "Search in Rotated Sorted Array",
    difficulty: "Medium",
    category: "Binary Search",
    description: "Search for `target` in a rotated sorted array. Return its index or -1.",
    starterCode: "function searchRotated(nums, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [4,5,6,7,0,1,2], target: 0 }, expected: 4 },
      { input: { nums: [4,5,6,7,0,1,2], target: 3 }, expected: -1 },
    ],
    hints: ["Modified binary search: identify the sorted half."],
    solution: "function searchRotated(nums, target) {\n  let l=0,r=nums.length-1;\n  while(l<=r) {\n    const m=Math.floor((l+r)/2);\n    if (nums[m]===target) return m;\n    if (nums[l]<=nums[m]) {\n      if (target>=nums[l]&&target<nums[m]) r=m-1; else l=m+1;\n    } else {\n      if (target>nums[m]&&target<=nums[r]) l=m+1; else r=m-1;\n    }\n  }\n  return -1;\n}",
    optimalComplexity: "O(log n)",
  },
  {
    id: "first-bad-version",
    title: "First Bad Version",
    difficulty: "Easy",
    category: "Binary Search",
    description: "Given `n` versions [1..n] and an API `isBadVersion(v)`, find the first bad version.",
    starterCode: "function firstBadVersion(n) {\n  // isBadVersion(v) is predefined\n  // Your solution here\n}",
    testCases: [],
    hints: ["Standard binary search for left boundary."],
    solution: "function firstBadVersion(n) {\n  let l=1,r=n;\n  while(l<r) {\n    const m=Math.floor((l+r)/2);\n    if (isBadVersion(m)) r=m; else l=m+1;\n  }\n  return l;\n}",
    optimalComplexity: "O(log n)",
  },
  {
    id: "median-two-sorted",
    title: "Median of Two Sorted Arrays",
    difficulty: "Hard",
    category: "Binary Search",
    description: "Given two sorted arrays `nums1` and `nums2`, return the median of the two sorted arrays. O(log(m+n)).",
    starterCode: "function findMedianSortedArrays(nums1, nums2) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums1: [1,3], nums2: [2] }, expected: 2 },
      { input: { nums1: [1,2], nums2: [3,4] }, expected: 2.5 },
    ],
    hints: ["Binary search on the shorter array to partition both arrays."],
    solution: "function findMedianSortedArrays(a, b) {\n  if (a.length>b.length) return findMedianSortedArrays(b,a);\n  const m=a.length,n=b.length,half=Math.floor((m+n+1)/2);\n  let l=0,r=m;\n  while(l<=r) {\n    const i=Math.floor((l+r)/2), j=half-i;\n    const aL=i>0?a[i-1]:-Infinity, aR=i<m?a[i]:Infinity;\n    const bL=j>0?b[j-1]:-Infinity, bR=j<n?b[j]:Infinity;\n    if (aL<=bR&&bL<=aR) {\n      if ((m+n)%2) return Math.max(aL,bL);\n      return (Math.max(aL,bL)+Math.min(aR,bR))/2;\n    }\n    if (aL>bR) r=i-1; else l=i+1;\n  }\n}",
    optimalComplexity: "O(log min(m,n))",
  },

  // ═══════════════════════  LINKED LISTS  ═══════════════════════════
  {
    id: "reverse-linked-list",
    title: "Reverse Linked List",
    difficulty: "Easy",
    category: "Linked Lists",
    description: "Given the `head` of a singly linked list, reverse the list and return the reversed list.",
    starterCode: "function reverseList(head) {\n  // Your solution here\n}",
    testCases: [
      { input: { head: [1,2,3,4,5] }, expected: [5,4,3,2,1], isLinkedList: true },
    ],
    hints: ["Three pointers: prev, current, next."],
    solution: "function reverseList(head) {\n  let prev=null, cur=head;\n  while(cur) { const next=cur.next; cur.next=prev; prev=cur; cur=next; }\n  return prev;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "merge-two-sorted-lists",
    title: "Merge Two Sorted Lists",
    difficulty: "Easy",
    category: "Linked Lists",
    description: "Merge two sorted linked lists into one sorted list.",
    starterCode: "function mergeTwoLists(list1, list2) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Use a dummy node and iterate."],
    solution: "function mergeTwoLists(l1, l2) {\n  const dummy={next:null}; let cur=dummy;\n  while(l1&&l2) {\n    if (l1.val<=l2.val) { cur.next=l1; l1=l1.next; }\n    else { cur.next=l2; l2=l2.next; }\n    cur=cur.next;\n  }\n  cur.next=l1||l2;\n  return dummy.next;\n}",
    optimalComplexity: "O(n+m)",
  },
  {
    id: "linked-list-cycle",
    title: "Linked List Cycle",
    difficulty: "Easy",
    category: "Linked Lists",
    description: "Given `head`, determine if the linked list has a cycle.",
    starterCode: "function hasCycle(head) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Floyd's tortoise and hare."],
    solution: "function hasCycle(head) {\n  let slow=head, fast=head;\n  while(fast&&fast.next) {\n    slow=slow.next; fast=fast.next.next;\n    if (slow===fast) return true;\n  }\n  return false;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "remove-nth-from-end",
    title: "Remove Nth Node From End of List",
    difficulty: "Medium",
    category: "Linked Lists",
    description: "Given the `head` of a linked list, remove the nth node from the end and return its head.",
    starterCode: "function removeNthFromEnd(head, n) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Two pointers with n gap."],
    solution: "function removeNthFromEnd(head, n) {\n  const dummy={next:head}; let fast=dummy, slow=dummy;\n  for (let i=0;i<=n;i++) fast=fast.next;\n  while(fast) { fast=fast.next; slow=slow.next; }\n  slow.next=slow.next.next;\n  return dummy.next;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "reorder-list",
    title: "Reorder List",
    difficulty: "Medium",
    category: "Linked Lists",
    description: "Reorder list L0→L1→...→Ln to L0→Ln→L1→Ln-1→L2→Ln-2→...",
    starterCode: "function reorderList(head) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Find middle, reverse second half, merge alternately."],
    solution: "function reorderList(head) {\n  let slow=head,fast=head;\n  while(fast.next&&fast.next.next) { slow=slow.next; fast=fast.next.next; }\n  let prev=null,cur=slow.next;\n  slow.next=null;\n  while(cur) { const t=cur.next; cur.next=prev; prev=cur; cur=t; }\n  let l1=head,l2=prev;\n  while(l2) { const t1=l1.next,t2=l2.next; l1.next=l2; l2.next=t1; l1=t1; l2=t2; }\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "merge-k-sorted-lists",
    title: "Merge k Sorted Lists",
    difficulty: "Hard",
    category: "Linked Lists",
    description: "Merge an array of `k` sorted linked-lists into one sorted linked-list.",
    starterCode: "function mergeKLists(lists) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Divide and conquer: merge pairs recursively."],
    solution: "function mergeKLists(lists) {\n  if (!lists.length) return null;\n  function merge2(a,b) {\n    const d={next:null}; let c=d;\n    while(a&&b) { if (a.val<=b.val) {c.next=a;a=a.next;} else {c.next=b;b=b.next;} c=c.next; }\n    c.next=a||b; return d.next;\n  }\n  while(lists.length>1) {\n    const merged=[];\n    for (let i=0;i<lists.length;i+=2) merged.push(i+1<lists.length?merge2(lists[i],lists[i+1]):lists[i]);\n    lists=merged;\n  }\n  return lists[0];\n}",
    optimalComplexity: "O(n log k)",
  },

  // ═══════════════════════  TREES  ══════════════════════════════════
  {
    id: "invert-binary-tree",
    title: "Invert Binary Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Given the `root` of a binary tree, invert the tree and return its root.",
    starterCode: "function invertTree(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Swap left and right children recursively."],
    solution: "function invertTree(root) {\n  if (!root) return null;\n  [root.left,root.right]=[invertTree(root.right),invertTree(root.left)];\n  return root;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "max-depth-binary-tree",
    title: "Maximum Depth of Binary Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Given the `root` of a binary tree, return its maximum depth.",
    starterCode: "function maxDepth(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Recursive: 1 + max(left depth, right depth)."],
    solution: "function maxDepth(root) {\n  if (!root) return 0;\n  return 1+Math.max(maxDepth(root.left),maxDepth(root.right));\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "same-tree",
    title: "Same Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Given the roots of two binary trees `p` and `q`, check if they are the same.",
    starterCode: "function isSameTree(p, q) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Recursive comparison."],
    solution: "function isSameTree(p, q) {\n  if (!p&&!q) return true;\n  if (!p||!q||p.val!==q.val) return false;\n  return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "subtree-of-another",
    title: "Subtree of Another Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Check if `subRoot` is a subtree of `root`.",
    starterCode: "function isSubtree(root, subRoot) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Check isSameTree at each node."],
    solution: "function isSubtree(root, sub) {\n  if (!root) return false;\n  if (isSame(root,sub)) return true;\n  return isSubtree(root.left,sub)||isSubtree(root.right,sub);\n  function isSame(a,b) {\n    if (!a&&!b) return true;\n    if (!a||!b||a.val!==b.val) return false;\n    return isSame(a.left,b.left)&&isSame(a.right,b.right);\n  }\n}",
    optimalComplexity: "O(m*n)",
  },
  {
    id: "lowest-common-ancestor",
    title: "Lowest Common Ancestor of a BST",
    difficulty: "Medium",
    category: "Trees",
    description: "Given a BST and two nodes `p` and `q`, find their lowest common ancestor.",
    starterCode: "function lowestCommonAncestor(root, p, q) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["If both values are less, go left. If both are greater, go right."],
    solution: "function lowestCommonAncestor(root, p, q) {\n  while(root) {\n    if (p.val<root.val&&q.val<root.val) root=root.left;\n    else if (p.val>root.val&&q.val>root.val) root=root.right;\n    else return root;\n  }\n}",
    optimalComplexity: "O(h)",
  },
  {
    id: "level-order-traversal",
    title: "Binary Tree Level Order Traversal",
    difficulty: "Medium",
    category: "Trees",
    description: "Return the level order traversal of a binary tree's nodes' values.",
    starterCode: "function levelOrder(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["BFS with a queue, process level by level."],
    solution: "function levelOrder(root) {\n  if (!root) return [];\n  const res=[], queue=[root];\n  while(queue.length) {\n    const level=[], size=queue.length;\n    for (let i=0;i<size;i++) {\n      const node=queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    res.push(level);\n  }\n  return res;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "validate-bst",
    title: "Validate Binary Search Tree",
    difficulty: "Medium",
    category: "Trees",
    description: "Given the `root` of a binary tree, determine if it is a valid BST.",
    starterCode: "function isValidBST(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Recursion with min/max bounds."],
    solution: "function isValidBST(root, min=-Infinity, max=Infinity) {\n  if (!root) return true;\n  if (root.val<=min||root.val>=max) return false;\n  return isValidBST(root.left,min,root.val)&&isValidBST(root.right,root.val,max);\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "kth-smallest-bst",
    title: "Kth Smallest Element in a BST",
    difficulty: "Medium",
    category: "Trees",
    description: "Given the `root` of a BST and an integer `k`, return the kth smallest value.",
    starterCode: "function kthSmallest(root, k) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["In-order traversal gives sorted order."],
    solution: "function kthSmallest(root, k) {\n  const stack=[];\n  let cur=root;\n  while(true) {\n    while(cur) { stack.push(cur); cur=cur.left; }\n    cur=stack.pop();\n    k--;\n    if (k===0) return cur.val;\n    cur=cur.right;\n  }\n}",
    optimalComplexity: "O(h + k)",
  },
  {
    id: "diameter-binary-tree",
    title: "Diameter of Binary Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Given the `root`, return the length of the diameter (longest path between any two nodes).",
    starterCode: "function diameterOfBinaryTree(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["At each node, diameter through it = left height + right height."],
    solution: "function diameterOfBinaryTree(root) {\n  let best=0;\n  function h(node) {\n    if (!node) return 0;\n    const l=h(node.left), r=h(node.right);\n    best=Math.max(best,l+r);\n    return 1+Math.max(l,r);\n  }\n  h(root); return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "balanced-binary-tree",
    title: "Balanced Binary Tree",
    difficulty: "Easy",
    category: "Trees",
    description: "Determine if a binary tree is height-balanced (depth of subtrees never differs by more than 1).",
    starterCode: "function isBalanced(root) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["DFS returning height; -1 for unbalanced."],
    solution: "function isBalanced(root) {\n  function h(n) {\n    if (!n) return 0;\n    const l=h(n.left), r=h(n.right);\n    if (l===-1||r===-1||Math.abs(l-r)>1) return -1;\n    return 1+Math.max(l,r);\n  }\n  return h(root)!==-1;\n}",
    optimalComplexity: "O(n)",
  },

  // ═══════════════════════  GRAPHS  ═════════════════════════════════
  {
    id: "number-of-islands",
    title: "Number of Islands",
    difficulty: "Medium",
    category: "Graphs",
    description: "Given a 2D binary grid, count the number of islands (connected regions of '1's).",
    starterCode: "function numIslands(grid) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["DFS/BFS from each unvisited '1', mark visited."],
    solution: "function numIslands(grid) {\n  let count=0;\n  for (let r=0;r<grid.length;r++) for (let c=0;c<grid[0].length;c++) {\n    if (grid[r][c]==='1') { count++; dfs(grid,r,c); }\n  }\n  return count;\n  function dfs(g,r,c) {\n    if (r<0||r>=g.length||c<0||c>=g[0].length||g[r][c]!=='1') return;\n    g[r][c]='0';\n    dfs(g,r+1,c);dfs(g,r-1,c);dfs(g,r,c+1);dfs(g,r,c-1);\n  }\n}",
    optimalComplexity: "O(m*n)",
  },
  {
    id: "clone-graph",
    title: "Clone Graph",
    difficulty: "Medium",
    category: "Graphs",
    description: "Given a reference of a node in a connected undirected graph, return a deep copy.",
    starterCode: "function cloneGraph(node) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["DFS/BFS with a map from old node to clone."],
    solution: "function cloneGraph(node) {\n  if (!node) return null;\n  const map=new Map();\n  function dfs(n) {\n    if (map.has(n)) return map.get(n);\n    const clone={val:n.val,neighbors:[]};\n    map.set(n,clone);\n    for (const nb of n.neighbors) clone.neighbors.push(dfs(nb));\n    return clone;\n  }\n  return dfs(node);\n}",
    optimalComplexity: "O(V+E)",
  },
  {
    id: "pacific-atlantic",
    title: "Pacific Atlantic Water Flow",
    difficulty: "Medium",
    category: "Graphs",
    description: "Given an m×n matrix of heights, return cells that can flow to both Pacific and Atlantic oceans.",
    starterCode: "function pacificAtlantic(heights) {\n  // Your solution here\n}",
    testCases: [],
    hints: ["Reverse BFS/DFS from ocean borders."],
    solution: "function pacificAtlantic(h) {\n  const m=h.length,n=h[0].length;\n  const pac=Array.from({length:m},()=>Array(n).fill(false));\n  const atl=Array.from({length:m},()=>Array(n).fill(false));\n  function dfs(r,c,vis,prev) {\n    if (r<0||r>=m||c<0||c>=n||vis[r][c]||h[r][c]<prev) return;\n    vis[r][c]=true;\n    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>dfs(r+dr,c+dc,vis,h[r][c]));\n  }\n  for (let r=0;r<m;r++) { dfs(r,0,pac,-Infinity); dfs(r,n-1,atl,-Infinity); }\n  for (let c=0;c<n;c++) { dfs(0,c,pac,-Infinity); dfs(m-1,c,atl,-Infinity); }\n  const res=[];\n  for (let r=0;r<m;r++) for (let c=0;c<n;c++) if (pac[r][c]&&atl[r][c]) res.push([r,c]);\n  return res;\n}",
    optimalComplexity: "O(m*n)",
  },
  {
    id: "course-schedule",
    title: "Course Schedule",
    difficulty: "Medium",
    category: "Graphs",
    description: "There are `numCourses` courses with prerequisites. Return `true` if you can finish all courses (no cycle).",
    starterCode: "function canFinish(numCourses, prerequisites) {\n  // Your solution here\n}",
    testCases: [
      { input: { numCourses: 2, prerequisites: [[1,0]] }, expected: true },
      { input: { numCourses: 2, prerequisites: [[1,0],[0,1]] }, expected: false },
    ],
    hints: ["Topological sort with DFS or BFS (Kahn's)."],
    solution: "function canFinish(n, pre) {\n  const adj=Array.from({length:n},()=>[]);\n  const indeg=Array(n).fill(0);\n  for (const [a,b] of pre) { adj[b].push(a); indeg[a]++; }\n  const q=[];\n  for (let i=0;i<n;i++) if (!indeg[i]) q.push(i);\n  let cnt=0;\n  while(q.length) {\n    const c=q.shift(); cnt++;\n    for (const nb of adj[c]) { indeg[nb]--; if (!indeg[nb]) q.push(nb); }\n  }\n  return cnt===n;\n}",
    optimalComplexity: "O(V+E)",
  },
  {
    id: "graph-valid-tree",
    title: "Graph Valid Tree",
    difficulty: "Medium",
    category: "Graphs",
    description: "Given `n` nodes and edges, determine if these edges form a valid tree (connected, no cycles).",
    starterCode: "function validTree(n, edges) {\n  // Your solution here\n}",
    testCases: [
      { input: { n: 5, edges: [[0,1],[0,2],[0,3],[1,4]] }, expected: true },
    ],
    hints: ["A tree has exactly n-1 edges and is connected. Use Union-Find."],
    solution: "function validTree(n, edges) {\n  if (edges.length!==n-1) return false;\n  const parent=Array.from({length:n},(_,i)=>i);\n  function find(x) { return parent[x]===x?x:parent[x]=find(parent[x]); }\n  for (const [a,b] of edges) {\n    const pa=find(a), pb=find(b);\n    if (pa===pb) return false;\n    parent[pa]=pb;\n  }\n  return true;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "word-search",
    title: "Word Search",
    difficulty: "Medium",
    category: "Graphs",
    description: "Given an m x n board and a word, find if the word exists in the grid by following adjacent cells.",
    starterCode: "function exist(board, word) {\n  // Your solution here\n}",
    testCases: [
      { input: { board: [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word: "ABCCED" }, expected: true },
    ],
    hints: ["Backtracking DFS from each cell."],
    solution: "function exist(board, word) {\n  const m=board.length,n=board[0].length;\n  function dfs(r,c,i) {\n    if (i===word.length) return true;\n    if (r<0||r>=m||c<0||c>=n||board[r][c]!==word[i]) return false;\n    const t=board[r][c]; board[r][c]='#';\n    const found=dfs(r+1,c,i+1)||dfs(r-1,c,i+1)||dfs(r,c+1,i+1)||dfs(r,c-1,i+1);\n    board[r][c]=t;\n    return found;\n  }\n  for (let r=0;r<m;r++) for (let c=0;c<n;c++) if (dfs(r,c,0)) return true;\n  return false;\n}",
    optimalComplexity: "O(m*n*4^L)",
  },

  // ═══════════════════════  DYNAMIC PROGRAMMING  ════════════════════
  {
    id: "climbing-stairs",
    title: "Climbing Stairs",
    difficulty: "Easy",
    category: "Dynamic Programming",
    description: "You are climbing a staircase with `n` steps. Each time you can climb 1 or 2 steps. How many distinct ways can you climb to the top?",
    starterCode: "function climbStairs(n) {\n  // Your solution here\n}",
    testCases: [
      { input: { n: 2 }, expected: 2 },
      { input: { n: 3 }, expected: 3 },
      { input: { n: 5 }, expected: 8 },
    ],
    hints: ["It's the Fibonacci sequence."],
    solution: "function climbStairs(n) {\n  if (n<=2) return n;\n  let a=1,b=2;\n  for (let i=3;i<=n;i++) { [a,b]=[b,a+b]; }\n  return b;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "coin-change",
    title: "Coin Change",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given coin denominations and an `amount`, return the fewest number of coins to make up that amount, or -1 if impossible.",
    starterCode: "function coinChange(coins, amount) {\n  // Your solution here\n}",
    testCases: [
      { input: { coins: [1,5,10,25], amount: 30 }, expected: 2 },
      { input: { coins: [2], amount: 3 }, expected: -1 },
    ],
    hints: ["DP: dp[i] = min coins to make amount i."],
    solution: "function coinChange(coins, amount) {\n  const dp=Array(amount+1).fill(Infinity); dp[0]=0;\n  for (let i=1;i<=amount;i++) for (const c of coins) if (c<=i) dp[i]=Math.min(dp[i],dp[i-c]+1);\n  return dp[amount]===Infinity?-1:dp[amount];\n}",
    optimalComplexity: "O(n*amount)",
  },
  {
    id: "longest-increasing-subseq",
    title: "Longest Increasing Subsequence",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
    starterCode: "function lengthOfLIS(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [10,9,2,5,3,7,101,18] }, expected: 4 },
    ],
    hints: ["DP or patience sorting (binary search)."],
    solution: "function lengthOfLIS(nums) {\n  const tails=[];\n  for (const n of nums) {\n    let l=0,r=tails.length;\n    while(l<r) { const m=(l+r)>>1; if (tails[m]<n) l=m+1; else r=m; }\n    tails[l]=n;\n  }\n  return tails.length;\n}",
    optimalComplexity: "O(n log n)",
  },
  {
    id: "word-break",
    title: "Word Break",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given a string `s` and a dictionary `wordDict`, return `true` if `s` can be segmented into dictionary words.",
    starterCode: "function wordBreak(s, wordDict) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "leetcode", wordDict: ["leet","code"] }, expected: true },
      { input: { s: "catsandog", wordDict: ["cats","dog","sand","and","cat"] }, expected: false },
    ],
    hints: ["DP: dp[i] = can s[0..i] be segmented."],
    solution: "function wordBreak(s, dict) {\n  const set=new Set(dict), dp=Array(s.length+1).fill(false);\n  dp[0]=true;\n  for (let i=1;i<=s.length;i++) for (let j=0;j<i;j++) {\n    if (dp[j]&&set.has(s.slice(j,i))) { dp[i]=true; break; }\n  }\n  return dp[s.length];\n}",
    optimalComplexity: "O(n^2)",
  },
  {
    id: "house-robber",
    title: "House Robber",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given an array of non-negative integers representing money at each house, determine the maximum money you can rob without robbing two adjacent houses.",
    starterCode: "function rob(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,2,3,1] }, expected: 4 },
      { input: { nums: [2,7,9,3,1] }, expected: 12 },
    ],
    hints: ["dp[i] = max(dp[i-1], dp[i-2] + nums[i])."],
    solution: "function rob(nums) {\n  let prev2=0, prev1=0;\n  for (const n of nums) { const cur=Math.max(prev1,prev2+n); prev2=prev1; prev1=cur; }\n  return prev1;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "maximum-subarray",
    title: "Maximum Subarray",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given an integer array `nums`, find the subarray with the largest sum.",
    starterCode: "function maxSubArray(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [-2,1,-3,4,-1,2,1,-5,4] }, expected: 6 },
    ],
    hints: ["Kadane's algorithm."],
    solution: "function maxSubArray(nums) {\n  let cur=nums[0], best=nums[0];\n  for (let i=1;i<nums.length;i++) { cur=Math.max(nums[i],cur+nums[i]); best=Math.max(best,cur); }\n  return best;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "unique-paths",
    title: "Unique Paths",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "A robot is on an m×n grid. It can only move right or down. How many unique paths are there from top-left to bottom-right?",
    starterCode: "function uniquePaths(m, n) {\n  // Your solution here\n}",
    testCases: [
      { input: { m: 3, n: 7 }, expected: 28 },
    ],
    hints: ["DP grid or combinatorics."],
    solution: "function uniquePaths(m, n) {\n  const dp=Array(n).fill(1);\n  for (let r=1;r<m;r++) for (let c=1;c<n;c++) dp[c]+=dp[c-1];\n  return dp[n-1];\n}",
    optimalComplexity: "O(m*n)",
  },
  {
    id: "decode-ways",
    title: "Decode Ways",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "A message of digits can be decoded to letters (1='A'..26='Z'). Given a string `s` of digits, return the number of ways to decode it.",
    starterCode: "function numDecodings(s) {\n  // Your solution here\n}",
    testCases: [
      { input: { s: "12" }, expected: 2 },
      { input: { s: "226" }, expected: 3 },
      { input: { s: "06" }, expected: 0 },
    ],
    hints: ["DP similar to climbing stairs but with constraints."],
    solution: "function numDecodings(s) {\n  if (s[0]==='0') return 0;\n  const n=s.length; let prev2=1,prev1=1;\n  for (let i=1;i<n;i++) {\n    let cur=0;\n    if (s[i]!=='0') cur+=prev1;\n    const two=Number(s.slice(i-1,i+1));\n    if (two>=10&&two<=26) cur+=prev2;\n    prev2=prev1; prev1=cur;\n  }\n  return prev1;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "longest-common-subseq",
    title: "Longest Common Subsequence",
    difficulty: "Medium",
    category: "Dynamic Programming",
    description: "Given two strings `text1` and `text2`, return the length of their longest common subsequence.",
    starterCode: "function longestCommonSubsequence(text1, text2) {\n  // Your solution here\n}",
    testCases: [
      { input: { text1: "abcde", text2: "ace" }, expected: 3 },
    ],
    hints: ["Classic 2D DP."],
    solution: "function longestCommonSubsequence(a, b) {\n  const m=a.length,n=b.length;\n  const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));\n  for (let i=1;i<=m;i++) for (let j=1;j<=n;j++) {\n    dp[i][j]=a[i-1]===b[j-1]?dp[i-1][j-1]+1:Math.max(dp[i-1][j],dp[i][j-1]);\n  }\n  return dp[m][n];\n}",
    optimalComplexity: "O(m*n)",
  },
  {
    id: "edit-distance",
    title: "Edit Distance",
    difficulty: "Hard",
    category: "Dynamic Programming",
    description: "Given two strings `word1` and `word2`, return the minimum number of operations (insert, delete, replace) to convert `word1` to `word2`.",
    starterCode: "function minDistance(word1, word2) {\n  // Your solution here\n}",
    testCases: [
      { input: { word1: "horse", word2: "ros" }, expected: 3 },
    ],
    hints: ["2D DP on the two strings."],
    solution: "function minDistance(a, b) {\n  const m=a.length,n=b.length;\n  const dp=Array.from({length:m+1},(_,i)=>Array(n+1).fill(0).map((_,j)=>i===0?j:j===0?i:0));\n  for (let i=1;i<=m;i++) for (let j=1;j<=n;j++) {\n    dp[i][j]=a[i-1]===b[j-1]?dp[i-1][j-1]:1+Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]);\n  }\n  return dp[m][n];\n}",
    optimalComplexity: "O(m*n)",
  },

  // ═══════════════════════  BACKTRACKING  ═══════════════════════════
  {
    id: "subsets",
    title: "Subsets",
    difficulty: "Medium",
    category: "Backtracking",
    description: "Given an integer array `nums` of unique elements, return all possible subsets (the power set).",
    starterCode: "function subsets(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,2,3] }, expected: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] },
    ],
    hints: ["Backtracking: include or exclude each element."],
    solution: "function subsets(nums) {\n  const res=[];\n  function bt(i,cur) {\n    res.push([...cur]);\n    for (let j=i;j<nums.length;j++) { cur.push(nums[j]); bt(j+1,cur); cur.pop(); }\n  }\n  bt(0,[]); return res;\n}",
    optimalComplexity: "O(2^n)",
  },
  {
    id: "combination-sum",
    title: "Combination Sum",
    difficulty: "Medium",
    category: "Backtracking",
    description: "Given an array of distinct integers `candidates` and a `target`, return all unique combinations that sum to `target`. You may reuse numbers.",
    starterCode: "function combinationSum(candidates, target) {\n  // Your solution here\n}",
    testCases: [
      { input: { candidates: [2,3,6,7], target: 7 }, expected: [[2,2,3],[7]] },
    ],
    hints: ["Backtracking with reuse allowed from current index onward."],
    solution: "function combinationSum(cands, target) {\n  const res=[];\n  function bt(i,cur,rem) {\n    if (rem===0) { res.push([...cur]); return; }\n    for (let j=i;j<cands.length;j++) {\n      if (cands[j]>rem) continue;\n      cur.push(cands[j]); bt(j,cur,rem-cands[j]); cur.pop();\n    }\n  }\n  bt(0,[],target); return res;\n}",
    optimalComplexity: "O(2^t)",
  },
  {
    id: "permutations",
    title: "Permutations",
    difficulty: "Medium",
    category: "Backtracking",
    description: "Given an array `nums` of distinct integers, return all possible permutations.",
    starterCode: "function permute(nums) {\n  // Your solution here\n}",
    testCases: [
      { input: { nums: [1,2,3] }, expected: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] },
    ],
    hints: ["Backtracking with a used set."],
    solution: "function permute(nums) {\n  const res=[];\n  function bt(cur,used) {\n    if (cur.length===nums.length) { res.push([...cur]); return; }\n    for (let i=0;i<nums.length;i++) {\n      if (used.has(i)) continue;\n      used.add(i); cur.push(nums[i]); bt(cur,used); cur.pop(); used.delete(i);\n    }\n  }\n  bt([],new Set()); return res;\n}",
    optimalComplexity: "O(n!)",
  },
  {
    id: "n-queens",
    title: "N-Queens",
    difficulty: "Hard",
    category: "Backtracking",
    description: "Place `n` queens on an n×n chessboard so that no two queens attack each other.",
    starterCode: "function solveNQueens(n) {\n  // Your solution here\n}",
    testCases: [
      { input: { n: 4 }, expected: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]] },
    ],
    hints: ["Backtracking row by row; track columns and diagonals."],
    solution: "function solveNQueens(n) {\n  const res=[], cols=new Set(), d1=new Set(), d2=new Set();\n  function bt(r, board) {\n    if (r===n) { res.push(board.map(row=>row.join(''))); return; }\n    for (let c=0;c<n;c++) {\n      if (cols.has(c)||d1.has(r-c)||d2.has(r+c)) continue;\n      board[r][c]='Q'; cols.add(c); d1.add(r-c); d2.add(r+c);\n      bt(r+1,board);\n      board[r][c]='.'; cols.delete(c); d1.delete(r-c); d2.delete(r+c);\n    }\n  }\n  bt(0,Array.from({length:n},()=>Array(n).fill('.'))); return res;\n}",
    optimalComplexity: "O(n!)",
  },
  {
    id: "letter-combinations-phone",
    title: "Letter Combinations of a Phone Number",
    difficulty: "Medium",
    category: "Backtracking",
    description: "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent.",
    starterCode: "function letterCombinations(digits) {\n  // Your solution here\n}",
    testCases: [
      { input: { digits: "23" }, expected: ["ad","ae","af","bd","be","bf","cd","ce","cf"] },
    ],
    hints: ["Map digits to letters, backtrack through positions."],
    solution: "function letterCombinations(digits) {\n  if (!digits) return [];\n  const map={'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'};\n  const res=[];\n  function bt(i,cur) {\n    if (i===digits.length) { res.push(cur); return; }\n    for (const c of map[digits[i]]) bt(i+1,cur+c);\n  }\n  bt(0,''); return res;\n}",
    optimalComplexity: "O(4^n)",
  },

  // ═══════════════════════  EXTRA (INTERVALS / MISC)  ═══════════════
  {
    id: "merge-intervals",
    title: "Merge Intervals",
    difficulty: "Medium",
    category: "Arrays & Sorting",
    description: "Given an array of `intervals`, merge all overlapping intervals.",
    starterCode: "function merge(intervals) {\n  // Your solution here\n}",
    testCases: [
      { input: { intervals: [[1,3],[2,6],[8,10],[15,18]] }, expected: [[1,6],[8,10],[15,18]] },
    ],
    hints: ["Sort by start, then merge greedily."],
    solution: "function merge(intervals) {\n  intervals.sort((a,b)=>a[0]-b[0]);\n  const res=[intervals[0]];\n  for (let i=1;i<intervals.length;i++) {\n    const last=res[res.length-1];\n    if (intervals[i][0]<=last[1]) last[1]=Math.max(last[1],intervals[i][1]);\n    else res.push(intervals[i]);\n  }\n  return res;\n}",
    optimalComplexity: "O(n log n)",
  },
  {
    id: "insert-interval",
    title: "Insert Interval",
    difficulty: "Medium",
    category: "Arrays & Sorting",
    description: "Insert a new interval into a sorted list of non-overlapping intervals and merge if necessary.",
    starterCode: "function insert(intervals, newInterval) {\n  // Your solution here\n}",
    testCases: [
      { input: { intervals: [[1,3],[6,9]], newInterval: [2,5] }, expected: [[1,5],[6,9]] },
    ],
    hints: ["Three phases: before overlap, merge, after overlap."],
    solution: "function insert(intervals, ni) {\n  const res=[]; let i=0;\n  while(i<intervals.length&&intervals[i][1]<ni[0]) res.push(intervals[i++]);\n  while(i<intervals.length&&intervals[i][0]<=ni[1]) { ni=[Math.min(ni[0],intervals[i][0]),Math.max(ni[1],intervals[i][1])]; i++; }\n  res.push(ni);\n  while(i<intervals.length) res.push(intervals[i++]);\n  return res;\n}",
    optimalComplexity: "O(n)",
  },
  {
    id: "meeting-rooms",
    title: "Meeting Rooms",
    difficulty: "Easy",
    category: "Arrays & Sorting",
    description: "Given an array of meeting time intervals [start, end], determine if a person can attend all meetings.",
    starterCode: "function canAttendMeetings(intervals) {\n  // Your solution here\n}",
    testCases: [
      { input: { intervals: [[0,30],[5,10],[15,20]] }, expected: false },
      { input: { intervals: [[7,10],[2,4]] }, expected: true },
    ],
    hints: ["Sort by start time, check for overlaps."],
    solution: "function canAttendMeetings(intervals) {\n  intervals.sort((a,b)=>a[0]-b[0]);\n  for (let i=1;i<intervals.length;i++) if (intervals[i][0]<intervals[i-1][1]) return false;\n  return true;\n}",
    optimalComplexity: "O(n log n)",
  },
];

// Helpers
export const getQuestionById = (id) => QUESTION_BANK.find((q) => q.id === id);
export const getQuestionsByCategory = (cat) => QUESTION_BANK.filter((q) => q.category === cat);
export const getQuestionsByDifficulty = (diff) => QUESTION_BANK.filter((q) => q.difficulty === diff);
export const getAllCategories = () => [...new Set(QUESTION_BANK.map((q) => q.category))];
export const getAllDifficulties = () => [...new Set(QUESTION_BANK.map((q) => q.difficulty))];

export default QUESTION_BANK;
